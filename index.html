<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Notch‑Tasker | Modern Productivity Suite</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <canvas id="dotted-matrix-canvas"></canvas>

  <header>
    <div class="logo-placeholder">
      <img src="assets/logo.svg" alt="Notch-Tasker Logo" onerror="this.onerror=null;this.src='https://placehold.co/150x50/ffffff/333333?text=Logo&font=inter';"/>
    </div>
    <div class="menu-toggle" id="menu-toggle-button">
        <i class="fas fa-bars"></i>
    </div>
    <nav id="main-nav">
      <a href="#app"><i class="fas fa-mobile-alt"></i>Apps</a>
      <a href="#contact"><i class="fas fa-envelope"></i>Contact</a>
    </nav>
  </header>

  <main>
      <section class="hero">
        <div class="hero-text">
          <h1>We focus on simple things.</h1>
          <p>At Tech Inaayra, we believe technology should empower, not overwhelm. That's why we dedicate ourselves to crafting elegant, intuitive applications that seamlessly integrate into your workflow. Our mission is to simplify complexity, enhance your daily productivity, and provide tools that are both simple and a effective to use.</p>
        </div>
      </section>

      <section id="app" class="app-section">
        <h2 class="section-title">Our Apps</h2>
        <div class="app-top-row">
          <div class="app-info-column">
            <div class="app-icon">
              <img src="assets/icon.png" alt="App Icon" onerror="this.onerror=null;this.src='https://placehold.co/140x140/f3f4f6/6b7280?text=Icon&font=inter';"/>
            </div>
            <h2><i class="fas fa-rocket"></i> Notch‑Tasker</h2>
            <p>
              Neural-enhanced task management with real-time collaboration and system integration. Experience the future of productivity.
            </p>
            <a href="#" class="download-button"><i class="fas fa-download"></i> Download for macOS</a>
          </div>

          <div class="app-features-column">
            <h2>Key Features</h2>
            <ul>
              <li><i class="fas fa-mouse-pointer"></i>Seamless Access: Launch via hover-activated notch or convenient menu bar app.</li>
              <li><i class="fas fa-list-check"></i>Effortless Organization: Intuitively create and manage your to-do lists.</li>
              <li><i class="fas fa-eye"></i>At-a-Glance Clarity: Easily add tasks and view your entire workflow instantly.</li>
            </ul>
          </div>
        </div>

        <div class="app-video-panel">
          <video controls poster="assets/timeline.png" onerror="this.onerror=null; this.parentElement.innerHTML = '<img src=\'https://placehold.co/1600x900/f3f4f6/6b7280?text=Video+Preview&font=inter\' alt=\'Video Preview Placeholder\'>';">
            <source src="assets/demp.mp4" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
        </div>
      </section>
  </main>
  <footer id="contact">
      <div class="footer-content">
          <p><i class="fas fa-envelope"></i> techinaayra@gmail.com</p>
          <div class="footer-links">
            <a href="privacy.html"><i class="fas fa-shield-alt"></i>Privacy</a>
            <a href="terms.html"><i class="fas fa-file-contract"></i>Terms</a>
          </div>
      </div>
      <div class="trademark">
          &copy; <span id="current-year"></span> Tech Inaayra. All rights reserved.
      </div>
  </footer>

  <script>
    // Set current year in footer
    document.getElementById('current-year').textContent = new Date().getFullYear();

    // Smooth scroll for navigation links
    document.querySelectorAll('nav a[href^="#"], .hero a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            const href = this.getAttribute('href');
            // Only prevent default for internal links starting with #
            if (href.startsWith('#')) {
                e.preventDefault();
                const targetId = href;
                // Special case for #contact to scroll to footer
                const targetElement = (targetId === '#contact')
                    ? document.getElementById('contact')
                    : document.querySelector(targetId);

                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth'
                    });
                }
                // Close mobile menu if open after clicking a link
                const nav = document.getElementById('main-nav');
                const menuToggle = document.getElementById('menu-toggle-button');
                if (nav && nav.classList.contains('active')) {
                    nav.classList.remove('active');
                    // Optional: Change hamburger icon back to bars if needed
                    if(menuToggle) menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
                }
            }
            // Allow default behavior for external links (like privacy.html, terms.html)
        });
    });

    // Basic mobile menu toggle functionality
    const menuToggleButton = document.getElementById('menu-toggle-button');
    const mainNav = document.getElementById('main-nav');

    if (menuToggleButton && mainNav) {
        menuToggleButton.addEventListener('click', () => {
            mainNav.classList.toggle('active');
            // Optional: Change icon to 'X' when menu is open
            if (mainNav.classList.contains('active')) {
                menuToggleButton.innerHTML = '<i class="fas fa-times"></i>';
            } else {
                menuToggleButton.innerHTML = '<i class="fas fa-bars"></i>';
            }
        });
    }

    // Dotted Matrix Animation Script
    const canvas = document.getElementById('dotted-matrix-canvas');
    if (canvas) {
        const ctx = canvas.getContext('2d');
        let dotsArray; // Array to hold all dot objects
        let animationFrameId; // To control animation loop

        // --- Dot Properties ---
        let dotSize = 1.2;
        let dotSpacing = 35;
        // Read properties from CSS variables
        let dotBaseColor = getComputedStyle(document.documentElement).getPropertyValue('--dot-color').trim();
        let dotMinOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-min-opacity'));
        let dotMaxOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-max-opacity'));
        let baseBgColor = getComputedStyle(document.documentElement).getPropertyValue('--light-bg').trim(); // Read background color

        // Function to set up the canvas dimensions and create dots
        function setupCanvas() {
            // Stop previous animation frame if running
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            canvas.width = window.innerWidth; // Set canvas width to window width
            canvas.height = window.innerHeight; // Set canvas height to window height

            // Re-read CSS variables in case they changed (e.g., theme switch)
            dotBaseColor = getComputedStyle(document.documentElement).getPropertyValue('--dot-color').trim();
            dotMinOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-min-opacity'));
            dotMaxOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-max-opacity'));
            baseBgColor = getComputedStyle(document.documentElement).getPropertyValue('--light-bg').trim();

            createDots(); // Initialize the dots
            animateDots(); // Start animation
        }

        // Dot class definition
        class Dot {
            constructor(x, y) {
                this.x = x; // X position
                this.y = y; // Y position
                this.size = dotSize; // Dot size
                // Calculate a random initial opacity within the allowed pulse range
                const minOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-min-opacity'));
                const maxOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-max-opacity'));
                this.opacity = Math.random() * (maxOpacity - minOpacity) + minOpacity;
                this.pulseSpeed = (Math.random() * 0.01) + 0.005; // Random speed for pulsing effect
                this.pulseDirection = Math.random() < 0.5 ? 1 : -1; // Random initial pulse direction (in or out)
            }

            // Method to draw the dot
            draw() {
                // Extract RGB values from the baseColor string to apply opacity
                const match = dotBaseColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                if (match) {
                    // Use extracted RGB with current opacity
                    ctx.fillStyle = `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${this.opacity})`;
                } else {
                    // Fallback color if regex fails - Updated to new dot color (Amber 500)
                    ctx.fillStyle = `rgba(245, 158, 11, ${this.opacity})`; // CHANGED
                }

                // Draw the circle
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Method to update the dot's opacity for pulsing effect
            update() {
                // Change opacity based on speed and direction
                this.opacity += this.pulseSpeed * this.pulseDirection;

                // Re-read min/max opacity in case they change dynamically
                const currentMinOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-min-opacity'));
                const currentMaxOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-max-opacity'));


                // Reverse direction if opacity goes out of bounds
                if (this.opacity > currentMaxOpacity || this.opacity < currentMinOpacity) {
                    // Clamp opacity to ensure it stays within bounds
                    this.opacity = Math.max(currentMinOpacity, Math.min(currentMaxOpacity, this.opacity));
                    this.pulseDirection *= -1; // Reverse pulse direction
                }
                this.draw(); // Redraw the dot with updated opacity
            }
        }

        // Function to create the grid of dots
        function createDots() {
            dotsArray = []; // Reset the array
            ctx.fillStyle = baseBgColor; // Set canvas background color
            ctx.fillRect(0, 0, canvas.width, canvas.height); // Draw canvas background

            // Re-read min/max opacity for initial dot creation
             const minOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-min-opacity'));
             const maxOpacity = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dot-pulse-max-opacity'));


            // Loop through grid positions to create dots
            for (let x = dotSpacing / 2; x < canvas.width + dotSpacing; x += dotSpacing) {
                for (let y = dotSpacing / 2; y < canvas.height + dotSpacing; y += dotSpacing) {
                    // Add a new dot to the array
                    dotsArray.push(new Dot(x, y));
                }
            }
        }

        // Animation loop function
        function animateDots() {
            // Clear the canvas by drawing the background color
            ctx.fillStyle = baseBgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);


            // Update and draw each dot in the array
            if (dotsArray) { // Ensure dotsArray is initialized
                 for (let i = 0; i < dotsArray.length; i++) {
                    dotsArray[i].update();
                }
            }

            // Request the next frame
            animationFrameId = requestAnimationFrame(animateDots);
        }

        // Debounce function to limit resize event calls
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        // Event listener to resize the canvas and recreate dots when window size changes
        const debouncedSetupCanvas = debounce(setupCanvas, 150); // Adjust wait time (ms) as needed
        window.addEventListener('resize', debouncedSetupCanvas);

        // Initial setup
        setupCanvas();

    } else {
        console.error("Dotted matrix canvas element not found.");
    }

  </script>
</body>
</html>